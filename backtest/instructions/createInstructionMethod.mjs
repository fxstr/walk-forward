import { performance } from 'perf_hooks';
import sortBy from '../dataHelpers/sortBy.mjs';
import groupBy from '../dataHelpers/groupBy.mjs';
import spinner from '../spinner/spinner.mjs';

/**
 * Abstract implementation for select, weight, trade.
 * @param {object} data                   Data as generated by useData
 * @param {function} instructionFunction  User-provided function that creates the instruction; is
 *                                        called with 3 arguments:
 *                                        - timeSeries entries for current entry, reverse
 *                                          chronological order
 *                                        - instrument name for current entry
 *                                        - timeSeries entries for all other instruments as a Map,
 *                                          key is instrument's name and value is instrument's data
 *                                          in reverse chronological order
 * @param {string} instructionField       Field in data.instructions that should be updated
 * @param {function} validateFunction     Function that validates return value from
 *                                        instructionFunction
 * @return {object}                       data as received in arguments with updated instructions
 */
export default (data, instructionFunction, instructionField, validateFunction = val => val) => {

    const output = spinner(`Executing ${instructionField} instructions â€¦`);
    const startTime = performance.now();

    if (typeof instructionFunction !== 'function') {
        throw new Error(`createInstructionMethod: Second argument must be a function, is ${instructionFunction} instead.`);
    }

    const { instrumentKey } = data;

    // Sort timeSeries and instructions the same way so that we can access the matching data pair
    // (same date and instrument) by using indexes.
    // const t0 = performance.now();
    const sortedData = [...data.timeSeries].sort(sortBy('date', instrumentKey));
    const sortedInstructions = [...data.instructions].sort(sortBy('date', 'instrument'));
    // const t1 = performance.now();
    // console.log('sorting createInstructionMethod took', t1 - t0);
    const dataGroupedByDate = groupBy(
        sortedData,
        item => item.get('date'),
    );

    if (sortedData.length !== sortedInstructions.length) {
        throw new Error(`createInstructionMethod: timeSeries and instructions must have the same size, is ${sortedData.length} vs. ${sortedInstructions.length}.`);
    }

    // Re-use dataForMethod to improve performance; if we don't optimize for speed, calls may
    // take a few minutes.
    // Using a reducer instead of a for-of loop slows things down heavily (a few seconds for
    // 140 instrs/50 years)
    const dataForMethod = new Map(Array
        .from(data.instruments)
        .map(instrumentName => [instrumentName, []]));

    // One entry per date, which contains an array of instructions (for every instrument available
    // on that date)
    // Just pushing to this array and flattening it at the end speeds things up a lot
    const instructionsByDate = [];

    // When calling instructionFunction, params for a certain date are always the same; therefore
    // we walk through timeSeries date by date, use the same params on one given date and just add
    // the new data to the previous date's data
    for (const [, dataForDate] of dataGroupedByDate) {

        // Go through timeSeries entries for every instrument on current date
        // Add data for current date (for all instruments that have data available) to
        // dataForMethod
        for (const dataSet of dataForDate) {
            // I don't like that: We're updating data on a structure we previously used as
            // an argument; it might have been modified by the user. But: This is *so* much faster
            // than cloning dataForMethod *and* all its values, that it just makes sense
            const previousValues = dataForMethod.get(dataSet.get(instrumentKey));
            previousValues.unshift(dataSet);
        }

        // Go through data for all instruments
        // Generate instructions for every instrument on current date
        const instructionSet = dataForDate.map((dataSet) => {

            const instrumentName = dataSet.get(instrumentKey);

            const validatedInstructions = validateFunction(instructionFunction(
                // First argument: Array of previous data for current instrument, where most
                // recent entry is at the start (can be accessed through [0])
                dataForMethod.get(instrumentName),
                // Second argument: Name of current instrument
                instrumentName,
                // Third argument: All timeSeries' previous entries as a Map, where they key is
                // the instrument's name; value is reversed, so that latest entry can be accessed
                // with [0]
                // If we filtered for all instruments *other* than instrumentName, we'd lose
                // approx. 89% of speed (45 sec for 140 instrs/50 years vs 5 sec)
                dataForMethod,
            ));

            return validatedInstructions;

        });

        // const instructionsForDate = [...prev.instructions, ...instructionSet];
        instructionsByDate.push(instructionSet);

    }



    const instructions = instructionsByDate.flat();
    const finalInstructions = sortedInstructions.map((instruction, index) => ({
        ...instruction,
        [instructionField]: instructions[index],
    }));


    const endTime = performance.now();
    const timeDiff = Math.round(endTime - startTime);
    const timePerInstruction = Math.round((timeDiff / sortedInstructions.length) * 100) / 100;
    output.succeed(`Executed ${instructionField}, created ${sortedInstructions.length} instructions in ${timeDiff} ms (${timePerInstruction} per instruction)`);

    return {
        ...data,
        instructions: finalInstructions,
    };

};

