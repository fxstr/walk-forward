import sortBy from '../dataHelpers/sortBy.mjs';
import groupBy from '../dataHelpers/groupBy.mjs';
import tradeForDate from './tradeForDate.mjs';

/**
 * Executes a trading strategy for every date.
 * @param  {Object} data    Data as generated by useData()
 * @return {Object}         The result of our trades, usually with one entry per bar, with the
 *                          following properties:
 *                          - cash: the amount of money not invested. Array of objects with
 *                            properties date and cash
 *                          - orders: Array of Maps, …
 */
export default configuration => (data) => {

    if (typeof configuration.capital !== 'number') {
        throw new Error(`trade: Pass config with property capital that is a number; you passed ${configuration.capital} instead.`);
    }

    const { instrumentKey } = data;
    const timeSeriesGroupedByDate = groupBy(
        [...data.timeSeries].sort(sortBy('date', instrumentKey)),
        item => item.get('date'),
    );
    const instructionsGroupedByDate = groupBy(
        [...data.instructions].sort(sortBy('date', 'instrument')),
        item => item.date,
    );


    // Create positions/orders for every entry in timeSeries
    return timeSeriesGroupedByDate.reduce((previous, [date, timeSeriesEntries], index) => {

        // Get instructions; as every entry in timeSeries has an entry in instructions, we can
        // directly access instructions with the index of timeSeries.
        const [, instructionSet] = instructionsGroupedByDate[index];

        // Creates a Map.<string, number> from timeSeries where key is the instrument name and
        // value is the price type
        const getPriceType = (series, type) => new Map(series
            .map(entry => [entry.get(data.instrumentKey), entry.get(type)]));

        // Map with key: instrumentName, value: open
        const openPrices = getPriceType(timeSeriesEntries, 'open');
        const closePrices = getPriceType(timeSeriesEntries, 'close');


        const previousEntry = previous.slice(-1).pop();

        const result = tradeForDate(
            date,
            openPrices,
            closePrices,
            instructionSet,
            // Configuration
            {
                investedRatio: data.configuration.investedRatio,
                maxRatioPerInstrument: data.configuration.maxRatioPerInstrument,
            },
            // Previous data
            {
                orders: previousEntry.orders,
                positions: previousEntry.positions,
                cash: previousEntry.cash,
                positionValues: previousEntry.positionValues,
            },
        );

        // On first run, previous are the initial values (-1) – don't store them
        if (index === 0) return [result];
        return [...previous, result];

    }, [{
        cash: configuration.capital,
        positionValues: new Map(),
        // Orders are executed on open, where they are taken as 'left overs' from the previous
        // close; therefore, let's start with an empty order from the bar *before* we started
        // our trades
        orders: new Map(),
        // Array of orders, see createOrder.mjs
        positions: [],
    }]);

};
