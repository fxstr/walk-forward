import sortBy from '../dataHelpers/sortBy.mjs';
import groupBy from '../dataHelpers/groupBy.mjs';
import tradeForDate from './tradeForDate.mjs';
import logger from '../logger/logger.mjs';

const { debug } = logger('WalkForward:trade');

/**
 * Executes a trading strategy for every date.
 * @param  {Object} data    Data as generated by useData()
 * @return {Object}         The result of our trades, usually with one entry per bar, with the
 *                          following properties:
 *                          - cash: the amount of money not invested. Array of objects with
 *                            properties date and cash
 *                          - orders: Array of Maps, â€¦
 */
export default (data, capital) => {

    if (typeof capital !== 'number') {
        throw new Error(`trade: Pass parameter capital that is a number; you passed ${capital} instead.`);
    }

    const { instrumentKey } = data;
    const timeSeriesGroupedByDate = groupBy(
        [...data.timeSeries].sort(sortBy('date', instrumentKey)),
        item => item.get('date'),
    );

    // Create positions/orders for every entry in timeSeries
    const tradeResult = timeSeriesGroupedByDate.reduce((
        previous,
        [date, timeSeriesEntries],
        index,
    ) => {

        // Get instructions for current date
        const instructionSet = data.instructions
            .filter(instruction => instruction.date === date);

        // Creates a Map.<string, number> from timeSeries where key is the instrument name and
        // value is the price type
        const getPriceType = (series, type) => new Map(series
            .map(entry => [entry.get(data.instrumentKey), entry.get(type)]));

        // Map with key: instrumentName, value: open
        const openPrices = getPriceType(timeSeriesEntries, 'open');
        const closePrices = getPriceType(timeSeriesEntries, 'close');


        const previousEntry = previous.slice(-1).pop();

        const result = tradeForDate(
            date,
            openPrices,
            closePrices,
            instructionSet,
            // Configuration
            {
                investedRatio: data.configuration.investedRatio,
                maxRatioPerInstrument: data.configuration.maxRatioPerInstrument,
            },
            // Previous data
            {
                orders: previousEntry.orders,
                positions: previousEntry.positions,
                cash: previousEntry.cash,
                positionValues: previousEntry.positionValues,
            },
        );

        const pad = nr => (nr < 10 ? `0${nr}` : `${nr}`);
        const dateObject = new Date(date);
        debug(
            '%o-%o-%o: Orders are %o, positions %o',
            pad(dateObject.getDate()), pad(dateObject.getMonth() + 1, dateObject.getFullYear()),
            result.orders,
            result.positions.map(pos => ({ instrument: pos.instrument, size: pos.size })),
        );

        // On first run, previous are the initial values (-1) â€“ don't store them
        if (index === 0) return [result];
        return [...previous, result];

    }, [{
        cash: capital,
        positionValues: new Map(),
        // Orders are executed on open, where they are taken as 'left overs' from the previous
        // close; therefore, let's start with an empty order from the bar *before* we started
        // our trades
        orders: new Map(),
        // Array of orders, see createOrder.mjs
        positions: [],
    }]);

    debug(
        'Trades executed, final amount is %d',
        tradeResult.cash + Array
            .from(tradeResult.slice(-1).pop().positionValues.values())
            .reduce((prev, value) => prev + value, 0),
    );

    return {
        ...data,
        result: tradeResult,
    };

};
