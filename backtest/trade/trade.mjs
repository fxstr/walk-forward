import { performance } from 'perf_hooks';
import groupBy from '../dataHelpers/groupBy.mjs';
import tradeForDate from './tradeForDate.mjs';
import logger from '../logger/logger.mjs';
import spinner from '../spinner/spinner.mjs';
import calculateMargins from './calculateMargins.mjs';
import getPointValuesForDate from './getPointValuesForDate.mjs';

const { debug } = logger('WalkForward:trade');

/**
 * Executes a trading strategy for every date.
 * @param  {object} data    Data as generated by useData()
 * @return {object[]}       The result of our trades with one entry per bar, with the
 *                          following properties
 *                          - cash (number): the amount of money not invested
 *                          - orders (Map): key is the instrument's name, value the order size
 *                          - positions (object[]): properties see createPosition
 */
export default (data, capital) => {

    const startTime = performance.now();
    const output = spinner('Start trading …');

    if (typeof capital !== 'number') {
        throw new Error(`trade: Pass parameter capital that is a number; you passed ${capital} instead.`);
    }


    // Map.<number, Map[]>: timeSeries grouped by date
    const timeSeriesGroupedByDate = groupBy(
        data.timeSeries,
        item => item.get('date'),
    );

    // Map.<number, object[]>: Instructions grouped by date
    const instructionsGroupedByDate = new Map(groupBy(
        data.instructions,
        ({ date }) => date,
    ));


    // Create positions/orders for every entry in timeSeries
    const tradeResult = timeSeriesGroupedByDate.reduce((
        previous,
        [date, timeSeriesEntries],
        index,
    ) => {

        output.setText(`Trading for year ${new Date(date).getFullYear()}`);

        // Get instructions for current date
        const instructionSet = instructionsGroupedByDate.get(date);

        // Get current relative margins (0–1), transform to Map.<string, number>
        const relativeMargins = calculateMargins(
            timeSeriesEntries,
            data.instrumentKey,
            data.configuration.getMargin,
        );

        // Creates a Map.<string, number> from timeSeries where key is the instrument name and
        // value is the price type (e.g. 'open')
        const getPriceType = (series, type) => new Map(series
            .map(entry => [entry.get(data.instrumentKey), entry.get(type)]));

        // Map with key: instrumentName, value: opening/closing price
        const openPrices = getPriceType(timeSeriesEntries, 'open');
        const closePrices = getPriceType(timeSeriesEntries, 'close');
        // Prices for the field that is used to generate order sizes from instruction's weight
        // (e.g. ATR for futures).
        const instructionFieldPrices = getPriceType(
            timeSeriesEntries,
            data.configuration.instructionField,
        );

        const previousEntry = previous.slice(-1).pop();

        // @type Map.<string, number>
        const pointValues = getPointValuesForDate(
            timeSeriesEntries.map(entry => entry.get(data.instrumentKey)),
            data.configuration.getPointValue,
            date,
        );

        const result = tradeForDate(
            date,
            openPrices,
            closePrices, // Remove
            instructionFieldPrices,
            instructionSet,
            pointValues,
            // Configuration
            // Map properties to make sure it will also work when we change the naming
            {
                investedRatio: data.configuration.investedRatio,
                maxRatioPerInstrument: data.configuration.maxRatioPerInstrument,
            },
            relativeMargins,
            // Previous data
            {
                orders: previousEntry.orders,
                positions: previousEntry.positions,
                cash: previousEntry.cash,
            },
        );

        // On first run, previous are the initial values (-1) – don't store them
        if (index === 0) return [result];
        return [...previous, result];

    }, [{
        cash: capital,
        // Orders are executed on open, where they are taken as 'left overs' from the previous
        // close; therefore, let's start with an empty order from the bar *before* we started
        // our trades
        orders: new Map(),
        // Array of positions for current date
        positions: [],
        date: null,
    }]);

    debug('Trades executed.');

    const endTime = performance.now();
    const totalTime = Math.round(endTime - startTime);
    const timePerEntry = Math.round((totalTime / timeSeriesGroupedByDate.length) * 100) / 100;
    output.succeed(`Trading done for ${timeSeriesGroupedByDate.length} dates in ${totalTime} ms, ${timePerEntry} ms per entry`);

    return {
        ...data,
        result: tradeResult,
    };

};
