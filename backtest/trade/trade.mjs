import { performance } from 'perf_hooks';
import groupBy from '../dataHelpers/groupBy.mjs';
import tradeForDate from './tradeForDate.mjs';
import logger from '../logger/logger.mjs';
import spinner from '../spinner/spinner.mjs';
import runInstructions from '../instructions/runInstructions.mjs';

const { debug } = logger('WalkForward:trade');

/**
 * Executes a trading strategy for every date and creates instructions at the same time. We
 * need to do this simoultaneously as indicatorFunctions need to have access to the positions
 * of the most date they're called for.
 * @param  {Object} data    Data as generated by useData()
 * @return {Object}         The result of our trades, usually with one entry per bar, with the
 *                          following properties:
 *                          - cash: the amount of money not invested. Array of objects with
 *                            properties date and cash
 *                          - orders: Array of Maps, …
 */
export default (data, capital) => {

    const startTime = performance.now();
    const output = spinner('Start trading …');

    if (typeof capital !== 'number') {
        throw new Error(`trade: Pass parameter capital that is a number; you passed ${capital} instead.`);
    }

    const timeSeriesGroupedByDate = groupBy(
        data.timeSeries,
        item => item.get('date'),
    );

    // Create positions/orders for every entry in timeSeries
    const executedTrades = timeSeriesGroupedByDate.reduce((
        previous,
        [date, timeSeriesEntries],
        index,
    ) => {


        const previousEntry = previous.slice(-1).pop();
        const previousResult = previousEntry.result;
        const previousInstructions = previousEntry.instructions;


        // Get instructions for current date
        const instructions = runInstructions(
            data.instructionFunctions,
            timeSeriesEntries,
            data.instrumentKey,
            previousInstructions.instructionFunctionArguments,
        );


        // Creates a Map.<string, number> from timeSeries where key is the instrument name and
        // value is the price type (e.g. 'open')
        const getPriceType = (series, type) => new Map(series
            .map(entry => [entry.get(data.instrumentKey), entry.get(type)]));

        const result = tradeForDate(
            date,
            getPriceType(timeSeriesEntries, 'open'),
            getPriceType(timeSeriesEntries, 'close'),
            instructions.instructions,
            // Configuration
            {
                investedRatio: data.configuration.investedRatio,
                maxRatioPerInstrument: data.configuration.maxRatioPerInstrument,
            },
            previousResult,
        );


        const newValue = {
            result,
            instructions,
        };


        // On first run, previous are the initial values (-1) – don't store them
        if (index === 0) return [newValue];
        return [...previous, newValue];


    }, [{
        result: {
            cash: capital,
            positionValues: new Map(),
            // Orders are executed on open, where they are taken as 'left overs' from the previous
            // close; therefore, let's start with an empty order from the bar *before* we started
            // our trades
            orders: new Map(),
            // Array of orders, see createOrder.mjs
            positions: [],
        },
        instructions: {
            instructionFunctionArguments: new Map(),
        },
    }]);

    debug(
        'Trades executed, final result is %d',
        executedTrades.slice(-1).pop().result,
    );

    const endTime = performance.now();
    const totalTime = Math.round(endTime - startTime);
    const timePerEntry = Math.round((totalTime / timeSeriesGroupedByDate.length) * 100) / 100;
    output.succeed(`Trading done for ${timeSeriesGroupedByDate.length} dates in ${totalTime} ms, ${timePerEntry} ms per entry`);

    return {
        ...data,
        // executedTrades is an array that contains one result entry per date; only get the results
        // and provide them on data.results
        result: executedTrades.map(({ result }) => result),
        // executedTrades is an array that contains an array of instructions for every date;
        // get the instructions and flat them out
        instructions: executedTrades.map(({ instructions }) => instructions).flat(),
    };

};
